#pragma warning(disable : 4996)

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include "base32/Base32.h"

const char *CRACKLAB = "CRACKLAB";

#ifdef __cplusplus
extern "C" {
#endif
	void _morfkey(void *key);
#ifdef __cplusplus
}
#endif

#pragma pack(push, 1)
typedef struct _KEY {
	unsigned char SomeBytes[16];
	unsigned char SomeCount;
	unsigned int  CipherText[2];
} KEY, *LPKEY;
#pragma pack(pop)

unsigned char table[256] = {
	0xFA, 0xFA, 0x7D, 0x7D, 0xDB, 0xD7, 0xF3, 0x6F,
	0x7D, 0xEE, 0x7E, 0xDE, 0x6F, 0x5F, 0x6F, 0xE7,
	0xD7, 0xF5, 0xBB, 0xF5, 0xBE, 0xBB, 0xF3, 0xDB,
	0xF5, 0xF3, 0xEE, 0xAF, 0xF9, 0xD7, 0xFC, 0xF9,
	0xD7, 0xBE, 0xF6, 0xF3, 0xDD, 0xB7, 0xFC, 0xE7,
	0x5F, 0xBE, 0xFC, 0xBD, 0x3F, 0x5F, 0xBE, 0x7E,
	0xBB, 0x9F, 0xF6, 0xF3, 0x7B, 0xDB, 0xDB, 0xD7,
	0xE7, 0x5F, 0x3F, 0x5F, 0x7E, 0xBB, 0x5F, 0xDE,
	0xF5, 0xF5, 0x7D, 0xBD, 0xF9, 0xFC, 0xFC, 0xF6,
	0x6F, 0x3F, 0xDD, 0xDD, 0xF9, 0xDB, 0xBB, 0xDB,
	0xBE, 0xBB, 0xE7, 0xED, 0xDE, 0xDB, 0x9F, 0x5F,
	0x3F, 0xDE, 0xF5, 0xB7, 0xBD, 0xF9, 0xBE, 0xED,
	0xEB, 0xEE, 0xE7, 0x5F, 0xDD, 0x7E, 0xD7, 0xD7,
	0xFA, 0xF3, 0x5F, 0x5F, 0x5F, 0xBB, 0xBE, 0xBE,
	0xDE, 0x77, 0xF6, 0xBB, 0xEB, 0xEB, 0x7B, 0xF9,
	0x6F, 0x5F, 0xFA, 0xFC, 0xAF, 0xFA, 0xE7, 0xEE,
	0x6F, 0x7E, 0x7E, 0xBE, 0xFC, 0xF5, 0xD7, 0x7B,
	0x6F, 0xAF, 0xBE, 0x7E, 0xDB, 0xE7, 0xE7, 0x9F,
	0xFA, 0x77, 0x7E, 0x7B, 0xFC, 0xDD, 0xFA, 0xDD,
	0xDB, 0xBE, 0xFA, 0xDB, 0xE7, 0xFC, 0xED, 0xDD,
	0xCF, 0x3F, 0xDB, 0xF3, 0xFC, 0x7D, 0xF6, 0xDE,
	0xBB, 0xF3, 0xFA, 0xDD, 0xBD, 0xBB, 0xF6, 0x6F,
	0x7E, 0xF9, 0xDB, 0xDB, 0xB7, 0xBD, 0xBB, 0xBE,
	0xFC, 0x5F, 0xBE, 0xFC, 0xEB, 0xDE, 0x5F, 0xF9,
	0xED, 0xF5, 0xF5, 0xF5, 0xBD, 0x7E, 0x9F, 0x7E,
	0xFA, 0xDE, 0x7E, 0xFA, 0x7E, 0xF6, 0xCF, 0xE7,
	0x77, 0x9F, 0x7E, 0x9F, 0xDE, 0x7E, 0xBE, 0xBD,
	0xBB, 0x7B, 0xBE, 0xFA, 0xFA, 0xBD, 0xBE, 0xBD,
	0xD7, 0xF5, 0xFC, 0x3F, 0x3F, 0xEB, 0xFA, 0xEE,
	0xEE, 0x7B, 0xF3, 0xBB, 0xDB, 0xD7, 0x7B, 0x5F,
	0xF6, 0x7E, 0xF6, 0x7B, 0xF5, 0xDD, 0xDD, 0xBD,
	0xBE, 0xDD, 0x77, 0xD7, 0xDE, 0xDE, 0xFA, 0x7B 
};

void xtea_encipher(unsigned int num_rounds, unsigned int *v, unsigned int const *k) {
	unsigned int i;
	unsigned int v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;
	for (i=0; i < num_rounds; i++) {
		v0 += ((((v1 << 4) ^ (v1 >> 5)) + v1) ^ sum) + k[sum & 3];
		sum += delta;
		v1 += ((((v0 << 4) ^ (v0 >> 5)) + v0) ^ sum) + k[(sum>>11) & 3];
	}
	v[0]=v0; v[1]=v1;
}

unsigned char bitcount(unsigned char b)
{
	unsigned char n = 0;

	for (int i = 0; i < 8; i++) {
		n += b & (1 << i) ? 1 : 0;
	}

	return n;
}

int calc(char *szName, char *szSerial)
{
	KEY Key = {0};

	unsigned char key[16];

	for (int i = 0; i < 16; i++) {
		key[i] = (unsigned char)szName[i % strlen(szName)] + (i + 1);
	}
	
	_morfkey(&key);

	memcpy(&Key.CipherText, &CRACKLAB, 8);
	xtea_encipher(32, (unsigned int *)&Key.CipherText, (unsigned int *)&key);

	srand(GetTickCount());

	for (int i = 0; i < 16; i++) {
		Key.SomeBytes[i] = rand() & table[key[i]];
		Key.SomeCount += bitcount(Key.SomeBytes[i]);
	}

	unsigned char base32_buffer[40];
	const char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	
	Base32::Encode32((unsigned char *)&Key, 0x19, (unsigned char *)&base32_buffer);
	Base32::Map32((unsigned char *)&base32_buffer, 40, (unsigned char *)&alphabet);
	
	for (int i = 0; i < 8; i++) {
		memcpy(&szSerial[i * 6], &base32_buffer[i * 5], 5);
		szSerial[(i + 1) * 5 + i] = '-';
	}
	szSerial[47] = '\0';

	return 0;
}

int main()
{
	char szName[256];
	char szSerial[48];

	printf("Keygen for CRACKL@B Contest 2010 (part 1)\nName:\t");
	scanf("%s", szName);

	calc(szName, szSerial);

	printf("Serial:\t%s\n", szSerial);

	if (!OpenClipboard(NULL)) {
		printf("\nCan't init clipboard\n\n");
		return -1;
	}

	EmptyClipboard();
	HGLOBAL hLic = GlobalAlloc(GMEM_ZEROINIT, sizeof(szSerial) + 1);
	void *lplic = GlobalLock(hLic);
	strcpy((char *)lplic, szSerial);
	GlobalUnlock(hLic);
	SetClipboardData(CF_TEXT, hLic);
	GlobalFree(hLic);
	CloseClipboard();	
	
	printf("\n\tSerial copy to clipboard\n\n");

	return 0;
}